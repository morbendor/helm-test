{{- if eq "gcplb" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for GCP Load Balancer Service Extensions. ==-
-=======================================================================================-

Next, configure a traffic extension for your Application Load Balancer as per the following instructions:
https://cloud.google.com/service-extensions/docs/configure-traffic-extensions

Configuration hints:
* For "Forwarding rules", select all forwarding rules that need to be protected.
* Under Extension chains > extension-chain-1 > Match condition, enter "true" (without quotation marks).
* For "Authority", enter any value.
* For "Backend service", select the backend service automatically created for the {{ include "gcplb.fullname" . }}-proxy service in your GKE cluster.
* For "Events", select the request/response components that require inspection.
* If you'd like the traffic extension to operate in fail-open mode for initial testing, you may tick the "Enabled" checkbox under "Fail open".

To check that WAF Anywhere is receiving requests and blocking malicious traffic, ensure that all pods in the WAF Anywhere namespace are ready (2/2) - this process should take about 2-3 minutes:

    kubectl get pods -n {{ .Release.Namespace }}

Once the pods are ready and your traffic extension if configured, attempt to simulate a malicious request to your protected forwarding rules using curl or through your browser (e.g. https://<GCP-LB-IP>/?a=cmd.exe).

The request should be blocked by the security rules.

NOTE: 
The real client IP address will be detected by the security engine only when using an external Application Load Balancer (either regional or global) which is accessed by a public IP.

-=======================================================================================-
{{- else if eq "istio" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for Istio. ==-
-=======================================================================================-
{{- if (eq 1 .Release.Revision)}}

{{- if (and .Values.global.autoInstall.restartIngressControllerDeployment  .Values.global.autoInstall.autoPatchIngressControllerResources) }}
The autoInstall option is fully enabled, your cluster should be protected in a couple of minutes.

{{- else if (eq false .Values.global.autoInstall.restartIngressControllerDeployment )}}

If your istio-ingressgateway deployment is already configured for mounting the LSE certificates, run the following bash command for changes to take into effect:

   kubectl rollout restart deploy {{ include "ingressController.deploymentName" . }} -n {{ include "ingressController.namespace" . }}

  *Important note: The Istio controller deploy name and namespace are taken from the 'global.ingressControllerDeploymentName' and 'global.ingressControllerNamespace' arguments of the Helm installation respectfully. If these names are not your names, please run the installation again with the correct name.

{{- else }}

If you have already configured your Istio Ingress Gateway deployment as instructed, your cluster should be protected in a couple of minutes (autoInstall.restartIngressControllerDeployment option enabled).

{{- end }}


---------------------SKIP PART IF ALREADY CONFIGURED---------------------
1. Otherwise, use the following command to create the necessary patch file for your Istio Ingress Gateway deployment (copy the entire block until the 2nd 'EOF'):

cat > istio-deployment-patch.yaml << EOF
---
spec:
  template:
    spec:
      containers:
        - name: istio-proxy
          volumeMounts:
            - mountPath: /etc/envoy/certs # volumeMount for security-engine root certificate
              name: ext-proc-filter-ca-root-cert
      volumes:
        - name: ext-proc-filter-ca-root-cert # volume for security-engine root certificate
          secret:
            defaultMode: 420
            secretName: lse-ca-cert-{{ .Release.Namespace }}
EOF

2. The following commands patches your Istio Ingress GW deployment:
   kubectl patch deploy {{ include "ingressController.deploymentName" . }} -n {{ include "ingressController.namespace" . }} --patch-file istio-deployment-patch.yaml && kubectl rollout restart deploy  {{ include "ingressController.deploymentName" . }} -n {{ include "ingressController.namespace" . }}

   *The Istio controller deploy name and namespace are taken from the 'global.ingressControllerDeploymentName' and 'global.ingressControllerNamespace' arguments of the Helm installation respectfully. If these names are not your names, please run the installation again with the correct name.
---------------------SKIP PART IF ALREADY CONFIGURED---------------------
{{- end }}
-=======================================================================================-
{{- else if eq "nginx" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for Ingress NGINX Controller. ==-
-=======================================================================================-
{{- if (eq 1 .Release.Revision)}}
{{- if (eq true .Values.global.autoInstall.autoPatchIngressControllerResources )}}

The autoInstall option is enabled, your cluster should be protected in a couple of minutes.
{{- else }}
If you have already configured your ingress-nginx-controller ConfigMap and Deployment as instructed, your cluster should be protected in a couple of minutes.
{{- end }}

{{- if ( .Values.checkPrerequisites) }}
---------------------CHECK LOGS FOR PREREQUISITES------------------------
Check logs of prerequisite job:

    kubectl logs job.batch/check-prerequisites-job -n {{ .Release.Namespace }}
{{- end }}

---------------------SKIP PART IF ALREADY CONFIGURED---------------------
Otherwise, follow the next steps:

1. Use the following command to create the necessary patch file for your ConfigMap (copy the entire block until the 2nd 'EOF'):

cat > cm-patch.yaml << EOF
---
data:
  allow-snippet-annotations: "true"
  enable-real-ip: "true"
  http-snippet: |-
    impv_waf_module_is_ssl off;
    impv_waf_module_gateway_ip localhost;
    impv_waf_module_gateway_port 10000;    
    impv_waf_max_gateway_grpc_recv_size 4194304;
    impv_waf_max_buffer_size 4194294;
    impv_waf_module_grpc_timeout 90000;
    impv_waf_request_headers_initial_send_mode DEFAULT;
    impv_waf_response_headers_initial_send_mode DEFAULT;
    impv_waf_request_body_initial_send_mode STREAMED;
    impv_waf_response_body_initial_send_mode STREAMED;    
  location-snippet: |
    impv_waf_module_protect on;
  main-snippet: |
    load_module /usr/lib/nginx/modules/imperva_waf_module.so;
  proxy-body-size: 10m
    impv_waf_module_pass_on_failure {{ (eq false .Values.global.failOpen) | ternary "off" "on" }};
EOF

2. Use the following commands to set the ConfigMap name as an environment variable and patch your ConfigMap:

    # Rename the CM name if needed and patch it
    export CONFIG_MAP={{ include "ingressController.deploymentName" . }} && kubectl patch cm $CONFIG_MAP -n {{ include "ingressController.namespace" . }} --type merge --patch-file cm-patch.yaml

3. Use the following command to create the necessary patch file for your Ingress Nginx controller (copy the entire block until the 2nd 'EOF'):

cat > nginx-deployment-patch.yaml << EOF
---
spec:
  template:
    spec:
      initContainers:
        - name: install-impv-plugin
          image: {{ include "image-path" (dict "root" .Values "image"  ( index .Values "anywhere-connectors" "nginx-ingress-controller" "auxImages" "nginxPlugin")) }}-{{ ( index .Values "anywhere-connectors" "nginx-ingress-controller" "base" "flavor") }}-{{ ( index .Values "anywhere-connectors" "nginx-ingress-controller" "base" "tag") }}
          command:
            - sh
            - -c
            - cp -r ./* /impv-waf-plugin/
          imagePullPolicy: IfNotPresent
          securityContext:
            allowPrivilegeEscalation: false
            capabilities:
              drop:
                - ALL
            readOnlyRootFilesystem: true
            runAsNonRoot: true
            runAsUser: 1000
            seccompProfile:
              type: RuntimeDefault
          terminationMessagePolicy: File
          volumeMounts:
            - mountPath: /impv-waf-plugin/
              name: impv-waf-plugin
      containers:
        - name: controller
          volumeMounts:
            - name: impv-waf-plugin
              mountPath: /usr/lib/nginx/modules/imperva_waf_module.so
              subPath: imperva_waf_module.so
            - name: impv-waf-plugin
              mountPath: /usr/local/lib/libexternal_grpc.so
              subPath: libexternal_grpc.so
            - name: impv-waf-plugin
              mountPath: /usr/local/lib/libabsl_vlog_config_internal.so.2407.0.0
              subPath: libabsl_vlog_config_internal.so.2407.0.0
            - name: impv-waf-plugin
              mountPath: /usr/local/lib/libabsl_log_internal_fnmatch.so.2407.0.0
              subPath: libabsl_log_internal_fnmatch.so.2407.0.0
        - name: envoy
          image: {{.Values.global.registry}}/imperva-waf-anywhere-beta-docker/envoy:v3
          imagePullPolicy: IfNotPresent
          terminationMessagePath: /dev/termination-log
          terminationMessagePolicy: File
          ports:
            - containerPort: 10000
              name: envoy-listener
              protocol: TCP
          volumeMounts:
            - name: envoy
              mountPath: /etc/envoy/envoy.yaml
              subPath: envoy.yaml
            - name: ext-proc-filter-ca-root-cert
              mountPath: /etc/envoy/ca.crt
              subPath: ca.crt
      volumes:
        - name: envoy
          configMap:
            name: envoy-sidecar
            defaultMode: 420
            items:
              - key: envoy.yaml
                path: envoy.yaml
        - name: ext-proc-filter-ca-root-cert
          secret:
            defaultMode: 420
            secretName: {{ include "security-engine.name" . }}-certs-{{ include "ingressController.namespace" . }}
        - name: impv-waf-plugin
          emptyDir:
            sizeLimit: 100Mi
      imagePullSecrets:
        - name: waf-anywhere-artifactory
EOF

4. Use the following commands to set the ingress name as an environment variable and patch your Ingress Nginx controller deployment:

    # Rename the Ingress Nginx controller name if needed and patch it
    export NGINX_CONTROLLER={{ include "ingressController.deploymentName" . }} && kubectl patch deploy $NGINX_CONTROLLER -n {{ include "ingressController.namespace" . }} --patch-file nginx-deployment-patch.yaml && kubectl rollout restart deploy $NGINX_CONTROLLER -n {{ include "ingressController.namespace" . }}

    *Important note: The Ingress Nginx namespace is taken from the 'global.ingressControllerNamespace' argument of the helm installation. If this is not your Nginx namespace, please run the installation again with the correct name.
---------------------SKIP PART IF ALREADY CONFIGURED---------------------

-=======================================================================================-
{{- end }}
{{- else if eq "kong" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for Kong Ingress Controller. ==-
-=======================================================================================-
{{- if (eq 1 .Release.Revision)}}

{{- if .Values.global.autoInstall.autoPatchIngressControllerResources }}
The autoInstall option is enabled. Your Kong Gateway deployment has been patched and restarted automatically in order to install the Imperva WAF Anywhere plugin.
Please note that an Envoy sidecar has been added to each Kong Gateway pod. This sidecar functions as a lightweight load balancer to your Elastic WAF pods.

Execute the following command and wait for the Kong Gateway pod(s) to report full readiness (2/2 containers).
   
kubectl get pod -n {{ include "ingressController.namespace" . }} --watch

{{- else }}

The autoInstall option is disabled. Execute the following commands for changes to take into effect:

1. Patch your Kong Gateway deployment to add and enable Imperva's WAF Anywhere plugin. 
This step will mount the plugin files into the main Kong container and modify the container's environment variables to enable the plugin.
Additionally, an Envoy sidecar will be added to your Kong Gateway deployment. This sidecar functions as a reverse proxy and a load balancer to your Elastic WAF pods.

DISCLAIMER: 
* Your Kong Gateway deployment will restart automatically following this operation.
* The Kong Gateway deployment name and namespace are derived from the 'global.ingressControllerDeploymentName' and 'global.ingressControllerNamespace' arguments of the Helm installation respectfully. If these names do not match yours, please delete the release and re-run the installation using the correct names.

kubectl get configmap kong-gateway-patch -o jsonpath='{.data.patch\.json}' -n {{ include "ingressController.namespace" . }} > imperva-kong-patch.json
kubectl patch deployment {{ include "ingressController.deploymentName" . }} -n {{ include "ingressController.namespace" . }} --patch-file imperva-kong-patch.json

Once the commands are executed, run the following command and wait for the Kong Gateway pod(s) to report full readiness (2/2 containers).
   
kubectl get pod -n {{ include "ingressController.namespace" . }} --watch

2. Create a KongClusterPlugin resource for the Imperva WAF Anywhere plugin.
This resource defines the plugin's configuration and allows it to be referenced by other Kubernetes resources.
By default, the plugin targets the Envoy sidecar attached to your Kong Gateway pod at localhost:10000, which handles the load balancing to your Elastic WAF pods.

NOTE: The 'kubernetes.io/ingress.class' annotation is required and must match the CONTROLLER_INGRESS_CLASS environment variable of your kong-controller pod(s) ('kong' by default).

INGRESS_CLASS=$(kubectl get deploy -n {{ include "ingressController.namespace" . }} kong-controller -o json | jq -r '.spec.template.spec.containers[] | select(.name=="ingress-controller") | .env[] | select(.name=="CONTROLLER_INGRESS_CLASS").value')
cat > imperva-kong-plugin.yaml << EOF
apiVersion: configuration.konghq.com/v1
kind: KongClusterPlugin
metadata:
  name: imperva-waf-plugin
  annotations:
    kubernetes.io/ingress.class: $INGRESS_CLASS
config:
  pass_on_failure: {{ .Values.global.failOpen }}
  grpc:
    url: localhost
    port: 10000
    is_ssl: false
    timeout: 30000
  limits:
    max_buffer_size: 4194304
    max_grpc_recv_size: 4194304
  initial_send_modes:
    request_headers: DEFAULT
    request_body: STREAMED
    response_headers: DEFAULT
    response_body: STREAMED
plugin: impv-waf-plugin
EOF

kubectl apply -f imperva-kong-plugin.yaml -n {{ .Release.Namespace }}
{{- end }}

NEXT STEPS:
To begin securing your traffic, the plugin must be explicitly activated for each applicable Ingress/HTTPRoute resource as outlined below:

1. List your cluster's Ingress/HTTPRoute resources for Kong and determine which ones you wish to protect:

   For Ingress resources:
   INGRESS_CLASS=$(kubectl get deploy -n {{ include "ingressController.namespace" . }} kong-controller -o json | jq -r '.spec.template.spec.containers[] | select(.name=="ingress-controller") | .env[] | select(.name=="CONTROLLER_INGRESS_CLASS").value')
   kubectl get ingress --all-namespaces -o json | jq --arg INGRESS_CLASS $INGRESS_CLASS '.items[] | select(.spec.ingressClassName == $INGRESS_CLASS) | {namespace: .metadata.namespace, name: .metadata.name}'

   For HTTPRoute resources:
   GATEWAY=<Enter your Gateway's name>
   kubectl get httproute --all-namespaces -o json | jq --arg GATEWAY $GATEWAY '.items[] | select(.spec.parentRefs[0].name == $GATEWAY) | {namespace: .metadata.namespace, name: .metadata.name}'

2. For each applicable Ingress/HTTPRoute resource, execute the following commands:
   2.1. Get the Ingress/HTTPRoute resource's currently activated plugins:

        For Ingress resources:        
        plugins=$(kubectl get ingress <ingress_name> -n <ingress_namespace> -o jsonpath='{.metadata.annotations.konghq\.com/plugins}')

        For HTTPRoute resources:
        plugins=$(kubectl get httproute <httproute_name> -n <httproute_namespace> -o jsonpath='{.metadata.annotations.konghq\.com/plugins}')

   2.2. Add "imperva-waf-plugin" to the activated plugins:
        
        For Ingress resources:
        kubectl annotate ingress <ingress_name> --overwrite -n <ingress_namespace> konghq.com/plugins=imperva-waf-plugin,$plugins

        For HTTPRoute resources:
        kubectl annotate httproute <httproute_name> --overwrite -n <httproute_namespace> konghq.com/plugins=imperva-waf-plugin,$plugins

   Once complete, all rules defined under the modified Ingress/HTTPRoute resources will be protected immediately as per your security policy.
{{- end }}
{{- else if eq "envoy" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for Envoy. ==-
-=======================================================================================-
{{- if (eq 1 .Release.Revision)}}
If you have already configured your envoy ConfigMap as instructed, your cluster should be protected in a couple of minutes.

{{- if ( .Values.checkPrerequisites) }}
---------------------CHECK LOGS FOR PREREQUISITES------------------------
Check logs of prerequisite job:

    kubectl logs job.batch/check-prerequisites-job -n {{ .Release.Namespace }}
{{- end }}


---------------------SKIP PART IF ALREADY CONFIGURED---------------------
To specify your destination service and port which will be protected, you need to do the following:

1. Open the ConfigMap imperva-envoy for editing with the following command:

        kubectl edit cm imperva-envoy -n {{ .Release.Namespace }}

    Add the destination service and port in the final section:

        socket_address:
          address: <service name> # Destination service name to be protected
          port_value: <service port> # Destination service port to be protected

    Save and exit from the editing mode.

2. Restart the deployment to apply the changes:

        kubectl rollout restart deploy imperva-envoy -n {{ .Release.Namespace }}


 * Note that these changes can also be configured straight from the Helm install command with the envoy.destinationServiceAddress and envoy.destinationServicePort parameters.
---------------------SKIP PART IF ALREADY CONFIGURED---------------------
-=======================================================================================-
{{- end }}
To check that WAF Anywhere is receiving requests and blocking malicious traffic, ensure that all pods in the WAF Anywhere namespace are ready (2/2) - this process should take about 2-3 minutes:

    kubectl get pods -n {{ .Release.Namespace }}

After the pods are ready, attempt to simulate malicious traffic to your ingress controller using curl or through your browser:

    # The ingress IP won't necessarily have an external IP (if you're using minikube for example), in that case, use the address you would normally use for INGRESS_IP.
    export INGRESS_IP=$(kubectl get svc imperva-envoy -n {{ .Release.Namespace }} -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")
    curl "$INGRESS_IP/?a=cmd.exe"

The request should be blocked by the security rules.
{{- end }}

{{- if has .Values.global.ingressType (list "nginx" "istio" "kong") }}

-=======================================================================================-
To check that WAF Anywhere is receiving requests and blocking malicious traffic, make sure that all pods in the WAF Anywhere and Ingress Controller namespaces are ready - this should take about 2-3 minutes:

    kubectl get pods -n {{ .Release.Namespace }}
    kubectl get pods -n {{ include "ingressController.namespace" . }}

After the pods are ready, attempt to simulate malicious traffic to your ingress controller using curl or through your browser:

    # The ingress IP won't necessarily have an external IP (if you're using minikube for example), in that case, use the address you would normally use for INGRESS_IP.
    export INGRESS_IP=$(kubectl get svc {{ include "ingressController.serviceName" . }} -n {{ include "ingressController.namespace" . }} -o jsonpath="{.status.loadBalancer.ingress[0].hostname}")
    curl "$INGRESS_IP/?a=cmd.exe"

The request should be blocked by the security rules.

For the official docs, please visit:
https://docs.imperva.com/bundle/waf-anywhere/page/waf-anywhere/upgrade.htm
{{- end }}

{{- if eq "envoy-gateway" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for Envoy Gateway. ==-
-=======================================================================================-

To check that WAF Anywhere is receiving requests and blocking malicious traffic, make sure that all pods in the WAF Anywhere namespace are ready - this should take about 2-3 minutes:

    kubectl get pods -n {{ .Release.Namespace }}

The following installation has successfully deployed:
  - "EnvoyExtensionPolicy" for each namespace containing specified HTTPRoutes services.
  - "BackendTLSPolicy" has been deployed in the {{ .Release.Namespace }} namespace.
  - "ReferenceGrant" (Optional - In case HTTPRoutes is in a different namespace from the release namespace) has also been created to ensure seamless communication between EnvoyExtensionPolicy instances in namespaces different from {{ .Release.Namespace }} namespace.

To list these resources apply the following commands:

    kubectl get EnvoyExtensionPolicy --all-namespaces
    kubectl get BackendTLSPolicy -n {{ .Release.Namespace }}
    kubectl get ReferenceGrant -n {{ .Release.Namespace }}

After the pods are ready, attempt to simulate malicious traffic to your gateway-controller using curl or through your browser:

    # The EXTERNAL-IP which is the IP/DNS name of the load balancer. It can be found under the ADDRESS column of the "Gateway" Component.
    kubectl get gateway -n <namepace of the Gateway component>
    
    export GATEWAY_ADDRESS=$(kubectl get gateway <gateway name> -n <namepace of the Gateway component> -o jsonpath="{.status.addresses[0].value}")
    curl $GATEWAY_ADDRESS/?a=cmd.exe
{{- end }}

{{- if eq "gloo" .Values.global.ingressType }}
-=======================================================================================-
-== Thank you for installing Imperva's WAF Anywhere solution version {{.Chart.Version}} for Gloo Gateway. ==-
-=======================================================================================-
{{- if .Values.global.autoInstall.autoPatchIngressControllerResources }}
The autoInstall option is enabled. Your Gloo Gateway deployment has been automatically patched to include the required ExtProc configuration. No further manual steps are necessary.

Note: An ExtProc section has been added to your Gloo Settings resource to enable integration with Imperva's WAF Anywhere solution.

{{- else }}

The autoInstall option is disabled. Please follow the steps below to manually enable Imperva's WAF Anywhere integration with your Gloo Gateway deployment:

1. Patch your Gloo Gateway deployment by updating the Settings resource as follows:

    kubectl patch settings default -n {{ include "ingressController.namespace" . }} --type merge --patch '
spec:
  extProc:
    failureModeAllow: {{ .Values.global.failOpen }}
    filterStage:
      predicate: Before
      stage: RouteStage
    grpcService:
      extProcServerRef:
        name: {{ .Values.securityEngineServiceName }}-upstream
        namespace: {{ .Release.Namespace }}
    processingMode:
      requestBodyMode: STREAMED
      responseBodyMode: STREAMED
'

Now the Gloo Gateway will use ExtProc while processing a request.

{{- end }}
To check that WAF Anywhere is receiving requests and blocking malicious traffic, make sure that all pods in the WAF Anywhere namespace are ready - this should take about 2-3 minutes:

    kubectl get pods -n {{ .Release.Namespace }}

After the pods are ready, attempt to simulate malicious traffic to your gateway-controller using curl or through your browser:

    # The EXTERNAL-IP which is the IP/DNS name of the load balancer. It can be found under the ADDRESS column of the "Gateway" Component.
    kubectl get gateway -n <namepace of the Gateway component>
    
    export GATEWAY_ADDRESS=$(kubectl get gateway <gateway name> -n <namepace of the Gateway component> -o jsonpath="{.status.addresses[0].value}")
    curl $GATEWAY_ADDRESS/?a=cmd.exe
{{- end }}